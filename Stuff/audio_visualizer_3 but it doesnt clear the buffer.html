<!DOCTYPE html>
<html>

<head>
	<title>Audio Visualizer 3.0</title>
	<link rel="icon" type="image/x-icon" href="https://drawesome4333.github.io/favicon.ico">
	<style>
		:root {
			--true-height: 100vh;
		}

		body {
			background-color: #fff;
			color: white;
		}

		.playlistItem {
			cursor: pointer;
			border-bottom: 1pt black solid;
			transition: all 0.5s ease-in-out;
			position: relative;
			top: 0px;
			height: 150px;
			width: 34vw;
			overflow: hidden;
			background-image: linear-gradient(to right, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
			direction: ltr;
		}

		.songTitle {
			font-size: 20pt;
			font-family: Verdana, Geneva, Tahoma, sans-serif;
		}

		.songCover {
			float: left;
			margin: 5px;
		}

		.playlistItem:hover {
			/*background-color:rgb(40, 40, 40);*/
			background-image: linear-gradient(to right, rgba(40, 40, 40, 1), rgba(40, 40, 40, 0.7), rgba(0, 0, 0, 0));
			height: 160px;
		}

		.playlistItem:-moz-dragover {
			border-top: 3pt solid blue;
		}

		.songInError:hover {
			/* background-color:rgb(240,140,140); */
			background-image: linear-gradient(to right, rgba(240, 140, 140, 1), rgba(240, 140, 140, 0.7), rgba(0, 0, 0, 0));
		}

		.songInError {
			/* background-color:rgb(170, 94, 94);  */
			background-image: linear-gradient(to right, rgba(170, 94, 94, 1), rgba(170, 94, 94, 0.7), rgba(0, 0, 0, 0));
		}

		.songPlaying:hover {
			/*background-color:rgb(140,140,240);  */
			background-image: linear-gradient(to right, rgba(140, 140, 240, 1), rgba(140, 140, 240, 0.7), rgba(0, 0, 0, 0));
		}

		.songPlaying {
			/*background-color:rgb(94,94,170);  */
			background-image: linear-gradient(to right, rgba(94, 94, 170, 1), rgba(94, 94, 170, 0.7), rgba(0, 0, 0, 0));
		}

		.songDisabled:hover {
			/*background-color:rgb(140,140,140);  */
			background-image: linear-gradient(to right, rgba(140, 140, 140, 1), rgba(140, 140, 140, 0.7), rgba(0, 0, 0, 0));
		}

		.songDisabled {
			/*background-color:rgb(94,94,94); */
			background-image: linear-gradient(to right, rgba(94, 94, 94, 1), rgba(94, 94, 94, 0.7), rgba(0, 0, 0, 0));
		}

		#playlist {
			width: 34vw;
			height: calc(var(--true-height)*0.75);
			overflow-y: scroll;
			position: relative;
			top: 0px;
			left: 0px;
			direction: rtl;
		}

		#player {
			width: 34vw;
			height: calc(var(--true-height)*0.25);
			background-image: linear-gradient(to right, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
			border-bottom: 2pt black solid;
		}

		#addSongs {
			background-image: linear-gradient(to right, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0));
			height: 90px;
			width: 34vw;
			text-align: center;

			transition: all 0.5s ease-in-out;
			font-size: 20pt;
			font-family: Verdana, Geneva, Tahoma, sans-serif;
			cursor: pointer;


		}

		#addSongs:hover {
			/*background-color:rgb(40, 40, 40);*/
			background-image: linear-gradient(to right, rgba(50, 50, 50, 1), rgba(0, 0, 0, 0));
		}

		#sidePanel {
			position: fixed;
			top: 0px;
			left: 0px;
			height: 100%;
			width: 134vw;
			background-image: linear-gradient(to right, rgba(0, 0, 0, 1), rgba(0, 0, 0, 0), rgba(0, 0, 0, 0), rgba(0, 0, 0, 0));
			transition: all 0.5s ease-in-out;
		}

		#sidePanel.hideToLeft {
			left: -34vw !important;
		}

		#sidePanelArrow {
			width: 100vw;
			height: calc(var(--true-height));
			float: right;
			opacity: 1;
			background-image: linear-gradient(to left, rgba(0, 0, 0, 0) 90%, rgba(0, 0, 0, 1) 99%, rgba(0, 0, 0, 0) 100%);
			transition: all 0.5s ease-in-out;
			font-size: 30pt;
			vertical-align: middle;
			line-height: calc(var(--true-height));
		}

		#sidePanelArrow.hideToLeft {
			width: 100vw;
		}

		#sidePanelArrow.hideToLeft:after {
			content: '\25B6' !important;
		}

		#sidePanelArrow:after {
			content: '\25C0';
		}

		canvas {
			z-index: -1;
			position: absolute;
			top: 0px;
			left: 0px;
			width: 100%;
			height: 100%;
		}

		#placeHolder {
			border: none;
		}

		::-webkit-scrollbar {
			width: 12px;
		}

		::-webkit-scrollbar-thumb {
			background-color: #444;
			width: 10px;
		}

		::-webkit-scrollbar-thumb:hover {
			background-color: #666;
		}

		::-webkit-scrollbar-track {
			background-color: #222;
		}
	</style>
</head>

<body onload="document.documentElement.style.setProperty('--true-height', window.innerHeight + 'px');"
	onresize="document.documentElement.style.setProperty('--true-height', window.innerHeight + 'px'); if(Graphics.gl){Graphics.resize();}">
	<div id="sidePanel">
		<div id="sidePanelArrow"
			onclick="this.parentElement.classList.toggle('hideToLeft'); this.classList.toggle('hideToLeft')"
			onmousemove="ArrowTimer = 3; this.style.opacity = 1;"></div>
		<div id="player">
			<audio id="audio" controls>
				<source id="src" type="audio/mp3">
				HTML5 Audio element is not supported on your browser.
			</audio>
			<br>
			<input type="button" value="Start Listening" onclick="start(); requestMic();">
			<select id="inputSelect" onchange="tryMic(parseInt(this.value));"></select>
		</div>
		<div id="playlist">
			<div id="addSongs" onclick="var eve=new MouseEvent('click'); start(); fileEle.dispatchEvent(eve);">
				<b>&#x2b</b><br>
				Add songs
			</div>
		</div>

		<input type="file" id="files" accept="audio/*;" multiple style="display: none;">
		<p id="op"></p>
	</div>
	<canvas id="can" width=1000 height=300></canvas>
	<script>
		var audioSrc = document.getElementById("src");
		var audioEle = document.getElementById("audio");
		var fileEle = document.getElementById("files");
		var playlistEle = document.getElementById("playlist");
		var placeHolder = document.createElement("Div");
		var addSongEle = document.getElementById("addSongs");//used as the "last playlist" item to allow drops into the final spot and allow shuffling
		var inputSelectEle = document.getElementById("inputSelect");
		var sidePanelArrow = document.getElementById("sidePanelArrow");
		var op = document.getElementById("op");
		var hasStarted = false;
		var audioDevices = [];
		var ct = document.getElementById("can").getContext("2d");
		var canvas = document.getElementById("can");
		var movingSongId = -1;
		var ArrowTimer = 3;

		setInterval(
			function () {
				if (ArrowTimer > 0) {
					ArrowTimer--;
					if (ArrowTimer === 0) {
						sidePanelArrow.style.opacity = "0";
					}
				}
			}, 1000);

		audioEle.addEventListener("error", function (e) {
			console.log("An error was triggered");
			console.log(e);
		});

		audioEle.addEventListener("progress", function (e) {
			Player.songs[Player.songId].hasProgressed = true;
		});

		audioEle.addEventListener("stalled", function (e) {
			console.log("A stalled event was triggered");
			console.log(e);
		});

		audioEle.addEventListener("ended", function (e) {
			Player.nextSong();
		});

		placeHolder.classList.add("playlistItem");
		placeHolder.style.height = "0px";
		placeHolder.id = "placeHolder";

		addSongEle.addEventListener("dragover", function (e) {
			e.preventDefault();
		});

		addSongEle.addEventListener("drop", function (e) {
			e.preventDefault();

			var id = e.dataTransfer.getData("text");
			var movedEle = document.getElementById(id);
			playlistEle.insertBefore(movedEle, this);
			var movedId = parseInt(movedEle.id.substring(5, 10), 10);
			var oldIndex = -1;
			var newIndex = 0;

			if (movingSongId === -1) {
				placeHolder.style.height = "200px";
				playlistEle.insertBefore(placeHolder, movedEle);
				movedEle.style.height = "0px";
				setTimeout(function () {
					Player.songs[movingSongId].playlistItem.removeAttribute("style");
					placeHolder.style.height = "0px";
					movingSongId = -1;
				}, 1)

				movingSongId = movedId;
			}

			Player.songOrder.push(Player.songs[movedId]);
			for (; newIndex < Player.songOrder.length; newIndex++) {
				//insert the song before the one that is reciving the drop
				if (Player.songOrder[newIndex].id == movedId) {
					oldIndex = newIndex;
					break;
				}
			}

			if (oldIndex >= 0) {
				//remove old song if it was found
				Player.songOrder.splice(oldIndex, 1);
			}

			if (Player.songId >= 0) {
				for (var i = 0; i < Player.songOrder.length; i++) {
					//Update the song number as the list changed
					if (Player.songOrder[i].id === Player.songId) {
						Player.songNumber = i;
						break;
					}
				}
			}
		});

		function Cube(x, y, z, size, color, light, musicSection = Math.floor(Math.random() * Sound.analyser.frequencyBinCount)) {
			this.x = x;
			this.y = y;
			this.z = z;
			this.yOffset = 0;
			this.ox = 0;//orbit point
			this.oy = 0;
			this.oz = -650;
			this.power = 0;
			this.oldPower = 0;
			this.dp = 0; //difference in power.
			this.light = light;
			this.tilt = (Math.random() - 0.5) * 60;
			this.orbit = Math.random() * 360;
			this.tiltOffset = Math.random() * 360 / 180 * Math.PI;//so all the cubes don't make an x
			this.maxDistance = 3000;
			this.minDistance = 100;
			this.orbitDistance = 300;
			this.musicSection = musicSection;
			this.size = size;//the size of the model
			this.scale = 1;//how the model is scaled

			this.color = color;
			this.bufferLength = 36;
			this.rotation = [0, 0, 0];//in degs.
			this.modelMat = Graphics.matrix.identity(4);
			this.normalMat = Graphics.matrix.identity(3);
			this.VBO = Graphics.gl.createBuffer();
			this.IBO = Graphics.gl.createBuffer();

			var lazyArray = [];
			for (var i = 0; i < 6; i++) {
				//because I am too lazy to type a 36 element array
				lazyArray.push(i * 4, i * 4 + 1, i * 4 + 2, i * 4, i * 4 + 3, i * 4 + 1)
			}

			Graphics.gl.bindBuffer(Graphics.gl.ELEMENT_ARRAY_BUFFER, this.IBO);
			Graphics.gl.bufferData(Graphics.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(lazyArray), Graphics.gl.STATIC_DRAW);
			//[x, y, z, r, g, b, nx, ny, nz, tx, ty]
			//used to update the VBO on a size or color (not scale) change
			this.buildVBO = function () {
				//half size
				var hs = this.size / 2;
				var c = this.color;
				var f = 1;
				if (this.light > -1) {
					f = -1;
				}
				var anotherArray = [
					-hs,  hs, hs, c[0], c[1], c[2], 0, 0, 1 * f, 0, 0,//front
					 hs, -hs, hs, c[0], c[1], c[2], 0, 0, 1 * f, 1, 1,
					 hs,  hs, hs, c[0], c[1], c[2], 0, 0, 1 * f, 1, 0,
					-hs, -hs, hs, c[0], c[1], c[2], 0, 0, 1 * f, 0, 1,

					-hs,  hs, -hs, c[0], c[1], c[2], -1 * f, 0, 0, 0, 0,//left
					-hs, -hs,  hs, c[0], c[1], c[2], -1 * f, 0, 0, 1, 1,
					-hs,  hs,  hs, c[0], c[1], c[2], -1 * f, 0, 0, 1, 0,
					-hs, -hs, -hs, c[0], c[1], c[2], -1 * f, 0, 0, 0, 1,

					 hs,  hs,  hs, c[0], c[1], c[2], 1 * f, 0, 0, 0, 0,//right
					 hs, -hs, -hs, c[0], c[1], c[2], 1 * f, 0, 0, 1, 1,
					 hs,  hs, -hs, c[0], c[1], c[2], 1 * f, 0, 0, 1, 0,
					 hs, -hs,  hs, c[0], c[1], c[2], 1 * f, 0, 0, 0, 1,

					-hs,  hs, -hs, c[0], c[1], c[2], 0, 1 * f, 0, 0, 0,//top
					 hs,  hs,  hs, c[0], c[1], c[2], 0, 1 * f, 0, 1, 1,
					 hs,  hs, -hs, c[0], c[1], c[2], 0, 1 * f, 0, 1, 0,
					-hs,  hs,  hs, c[0], c[1], c[2], 0, 1 * f, 0, 0, 1,

					-hs, -hs,  hs, c[0], c[1], c[2], 0, -1 * f, 0, 0, 0,//bottom
					 hs, -hs, -hs, c[0], c[1], c[2], 0, -1 * f, 0, 1, 1,
					 hs, -hs,  hs, c[0], c[1], c[2], 0, -1 * f, 0, 1, 0,
					-hs, -hs, -hs, c[0], c[1], c[2], 0, -1 * f, 0, 0, 1,

					 hs,  hs, -hs, c[0], c[1], c[2], 0, 0, -1 * f, 0, 0,//back
					-hs, -hs, -hs, c[0], c[1], c[2], 0, 0, -1 * f, 1, 1,
					-hs,  hs, -hs, c[0], c[1], c[2], 0, 0, -1 * f, 1, 0,
					 hs, -hs, -hs, c[0], c[1], c[2], 0, 0, -1 * f, 0, 1];

				Graphics.gl.bindBuffer(Graphics.gl.ARRAY_BUFFER, this.VBO);
				Graphics.gl.bufferData(Graphics.gl.ARRAY_BUFFER, new Float32Array(anotherArray), Graphics.gl.STATIC_DRAW);
			}
			this.update = function () {

				this.OldPower = this.power;
				if (this.OldPower != 0) {
					this.dp = this.power / this.OldPower / 1.5;
				}
				if (this.power < Sound.data.frequency[musicSection] / 255) {
					this.power = Sound.data.frequency[musicSection] / 255;
				} else {
					if (this.power > 0)
						this.power -= 0.1;
					if (this.power < 0) {
						this.power = 0;
					}
				}

				this.scale = this.power * 5;
				this.orbit += this.power * 0.5 * (this.maxDistance / this.orbitDistance);
				this.orbit %= 360;
				this.yOffset += this.power / 50;
				this.orbitDistance += (this.power * this.power - 0.25) * 10 * (this.maxDistance / this.orbitDistance);
				this.rotation[0] += this.power * 2;
				this.rotation[1] += this.power * 2 + 0.1;
				if (this.orbitDistance > this.maxDistance) {
					this.orbitDistance = this.maxDistance;
				} else if (this.orbitDistance < this.minDistance) {
					this.orbitDistance = this.minDistance;
				}
				var orbit = this.orbit / 180 * Math.PI;
				var tilt = this.tilt / 180 * Math.PI;

				this.oy = Math.sin(this.yOffset) * 1000 / (this.orbitDistance / 100);
				var oldX = 0;
				var oldY = 0;
				var oldZ = 0;
				this.x = this.orbitDistance * Math.cos(orbit);
				this.y = 0;
				this.z = this.orbitDistance * Math.sin(orbit);
				oldX = this.x;
				oldY = this.y;
				this.x = oldX * Math.cos(tilt) - oldY * Math.sin(tilt);
				this.y = oldX * Math.sin(tilt) + oldY * Math.cos(tilt) + this.oy;
				oldX = this.x;
				oldZ = this.z;
				this.x = oldX * Math.cos(this.tiltOffset) - oldZ * Math.sin(this.tiltOffset) + this.ox;
				this.z = oldX * Math.sin(this.tiltOffset) + oldZ * Math.cos(this.tiltOffset) + this.oz;
				this.buildModelMat();
				if (this.light > -1) {
					Graphics.lightPos[this.light * 3] = this.x;
					Graphics.lightPos[this.light * 3 + 1] = this.y;
					Graphics.lightPos[this.light * 3 + 2] = this.z;

					Graphics.lightColor[this.light * 3] = this.color[0] * this.power + 0.1;
					Graphics.lightColor[this.light * 3 + 1] = this.color[1] * this.power + 0.1;
					Graphics.lightColor[this.light * 3 + 2] = this.color[2] * this.power + 0.1;
				}
			}
			this.buildModelMat = function () {
				var xr = this.rotation[0] * Math.PI / 180;
				var yr = this.rotation[1] * Math.PI / 180;
				var zr = this.rotation[2] * Math.PI / 180;
				var xm = [
					1, 0, 0,
					0, Math.cos(xr), -Math.sin(xr),
					0, Math.sin(xr),  Math.cos(xr)];
				var ym = [
					 Math.cos(yr), 0, Math.sin(yr),
					0, 1, 0,
					-Math.sin(yr), 0, Math.cos(yr)];
				var zm = [
					Math.cos(zr), -Math.sin(zr), 0,
					Math.sin(zr),  Math.cos(zr), 0,
					0, 0, 1];
				this.normalMat = Graphics.matrix.mult3x3([
					this.scale, 0, 0,
					0, this.scale, 0,
					0, 0, this.scale], xm);
				this.normalMat = Graphics.matrix.mult3x3(this.normalMat, ym);
				this.normalMat = Graphics.matrix.mult3x3(this.normalMat, zm);
				this.modelMat = Graphics.matrix.mult4x4([
					this.normalMat[0], this.normalMat[1], this.normalMat[2], 0,
					this.normalMat[3], this.normalMat[4], this.normalMat[5], 0,
					this.normalMat[6], this.normalMat[7], this.normalMat[8], 0,
					0, 0, 0, 1],
					[
						1, 0, 0, 0,
						0, 1, 0, 0,
						0, 0, 1, 0,
						this.x, this.y, this.z, 1])

			};
			this.buildVBO();
			this.buildModelMat();
		}
		var Graphics = {
			canvas: document.createElement("CANVAS"),
			gl: null,
			canvas_settings: {
				width: 0,
				height: 0,
				top: 0,
				left: 0,
				p_width: 0,
				p_height: 0,//previous width/height, lets a function know if the view port needs to be updated
				fullScreen: false,//if true the canvas will attempt to take up the whole screen
				shouldShow: true
			},
			settings: {
				backgroundColorSmoothing: 0.7 // to reduce strobe
			},
			particles: {

			},
			lightPos: [0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0,  0, 0, 0],
			lightColor: [0.25, 0.25, 0.25,  0.5, 0.0, 0.0,  0.0, 0.5, 0.0,  0.5, 0.5, 0.0,  0.0, 0.0, 0.5,  0.5, 0.0, 0.5,  0.0, 0.5, 0.5,  0.0, 0.0, 0.5],
			backgroundColor: [0, 0, 0],
			backgroundColorGoal: [0, 0, 0],
			cubes: [],
			state: {
				mode: -1,//-2 is fatal error(IE no WebGL or Audioapi),-1 is not running, 0 is frequencyParticles, 1 is cubeField, 2 is cubeWaveForm
				particles: true//wether or not to do particles on modes that don't require it
			},
			camera: {
				height: 0,
				target: {
					x: 0,
					y: 0,
					z: -650
				},
				matrix: null,
				angle: 0,
				direction: 1
			},
			textures: {
				plainWhite: null,
				transparentBlack: null
			},
			shaderSources: {
				mainVertexShader: "\n\
					attribute vec3 pos;\n\
					attribute vec3 color;\n\
					attribute vec2 tex;\n\
					attribute vec3 normal;\n\
					varying vec3 f_pos;\n\
					varying vec3 f_color;\n\
					varying vec3 f_normal;\n\
					varying vec2 f_tex;\n\
					uniform mat4 world;\n\
					uniform mat4 model;\n\
					uniform mat4 perspective;\n\
					uniform mat3 normal_matrix;\n\
					void main(void){\n\
						f_color = color;\n\
						f_normal = normal_matrix * normal;\n\
						f_tex = tex;\n\
						f_pos = (world*model * vec4(pos, 1.0)).xyz;\n\
						gl_Position=(perspective * world * model * vec4(pos, 1.0));\n\
					}",
				mainFragmentShader: "\n\
					precision mediump float;\n\
					varying vec3 f_pos;\n\
					varying vec3 f_color;\n\
					varying vec3 f_normal;\n\
					varying vec2 f_tex;\n\
					uniform vec3 light_pos[8];\n\
					uniform vec3 light_color[8];\n\
					uniform sampler2D texture;\n\
					uniform vec3 fog_color;\n\
					uniform vec3 ambient_color;\n\
					void main(void){\n\
						\n\
						vec3 normal = normalize(f_normal);\n\
						vec3 total_light = vec3(0.0, 0.0, 0.0);\n\
						float light_strength = 0.0;\n\
						float spec_strength = 0.0;\n\
						vec3 surface_to_light = vec3(0.0, 0.0, 0.0);\n\
						vec3 surface_to_camera = normalize(-f_pos);\n\
						vec3 half_vector = vec3(0.0, 0.0, 0.0);\n\
						vec3 base = f_color * texture2D(texture, f_tex).rgb;\n\
						\n\
						for(int i = 0; i < 8; i++){\n\
							surface_to_light = normalize(light_pos[i] - f_pos);\n\
							light_strength = max(dot(normal, surface_to_light), 0.0);\n\
							half_vector = normalize(surface_to_light + surface_to_camera);\n\
							spec_strength = pow(max(dot(half_vector, normal), 0.0), 100.0);\n\
							total_light += base * (light_strength * light_color[i]);\n\
							total_light += base * (spec_strength * light_color[i]);\n\
						}\n\
						total_light += ambient_color * base;\n\
						float amount = smoothstep(900.0, 1000.0, gl_FragCoord.z);\n\
						gl_FragColor = vec4(mix(total_light,fog_color,amount),texture2D(texture,f_tex).a);\n\
						\n\
					}",
				fadeVertexShader: "\n\
					attribute vec2 pos;\n\
					varying vec2 _pos;\n\
					void main(void){\n\
						_pos = pos;\n\
						gl_Position=vec4(pos, 1.0, 1.0);\n\
					}",
				fadeFragmentShader: "\n\
					precision mediump float;\n\
					uniform int freq[64];\n\
					uniform float opacity;\n\
					uniform vec3 color;\n\
					varying vec2 _pos;\n\
					vec4 fin;\n\
					int x;\n\
					float y;\n\
					void main(void){\n\
						\n\
						x = int(abs(_pos.x) * 64.0);\n\
						fin = vec4(vec3(1.0,1.0,1.0) - color.rgb , opacity);\n\
						for(int i = 0; i < 64; i++) {\n\
							if(i == x) {\n\
								y = float(freq[i]) / 255.0;\n\
								if (abs(_pos.y) < y){\n\
									fin = vec4(color.rgb, opacity);\n\
								}\n\
								break;\n\
							}\n\
						}\n\
						gl_FragColor = fin;\n\
						\n\
					}"
			},
			uniforms: {
				main: {
					world: null,
					model: null,
					perspective: null,
					normal_matrix: null,
					light_pos: null,
					light_color: null,
					texture: null,
					fog_color: null,
					ambient_color: null

				},
				fade: {
					opacity: null,
					color: null,
					freq: null
				}
			},
			attributes: {
				main: {
					pos: null,
					color: null,
					tex: null,
					normal: null
				},
				fade: {
					pos: null
				}
			},
			programs: {
				main: null,
				fade: null
			},
			shaders: {
				vertexShaders: {
					main: null,
					fade: null
				},
				fragmentShaders: {
					main: null,
					fade: null
				}
			},
			buffers: {
				fadeCoverPoints: null,
				fadeCoverTriangles: null
			},
			matrix: {
				mult4x4: function (matA, matB) {
					return [
						matA[ 0] * matB[0] + matA[ 1] * matB[4] + matA[ 2] * matB[8] + matA[ 3] * matB[12], matA[ 0] * matB[1] + matA[ 1] * matB[5] + matA[ 2] * matB[9] + matA[ 3] * matB[13], matA[ 0] * matB[2] + matA[ 1] * matB[6] + matA[ 2] * matB[10] + matA[ 3] * matB[14], matA[ 0] * matB[3] + matA[ 1] * matB[7] + matA[ 2] * matB[11] + matA[ 3] * matB[15],
						matA[ 4] * matB[0] + matA[ 5] * matB[4] + matA[ 6] * matB[8] + matA[ 7] * matB[12], matA[ 4] * matB[1] + matA[ 5] * matB[5] + matA[ 6] * matB[9] + matA[ 7] * matB[13], matA[ 4] * matB[2] + matA[ 5] * matB[6] + matA[ 6] * matB[10] + matA[ 7] * matB[14], matA[ 4] * matB[3] + matA[ 5] * matB[7] + matA[ 6] * matB[11] + matA[ 7] * matB[15],
						matA[ 8] * matB[0] + matA[ 9] * matB[4] + matA[10] * matB[8] + matA[11] * matB[12], matA[ 8] * matB[1] + matA[ 9] * matB[5] + matA[10] * matB[9] + matA[11] * matB[13], matA[ 8] * matB[2] + matA[ 9] * matB[6] + matA[10] * matB[10] + matA[11] * matB[14], matA[ 8] * matB[3] + matA[ 9] * matB[7] + matA[10] * matB[11] + matA[11] * matB[15],
						matA[12] * matB[0] + matA[13] * matB[4] + matA[14] * matB[8] + matA[15] * matB[12], matA[12] * matB[1] + matA[13] * matB[5] + matA[14] * matB[9] + matA[15] * matB[13], matA[12] * matB[2] + matA[13] * matB[6] + matA[14] * matB[10] + matA[15] * matB[14], matA[12] * matB[3] + matA[13] * matB[7] + matA[14] * matB[11] + matA[15] * matB[15],
					];
				},
				mult3x3: function (matA, matB) {
					return [
						matA[0] * matB[0] + matA[1] * matB[3] + matA[2] * matB[6], matA[0] * matB[1] + matA[1] * matB[4] + matA[2] * matB[7], matA[0] * matB[2] + matA[1] * matB[5] + matA[2] * matB[8],
						matA[3] * matB[0] + matA[4] * matB[3] + matA[5] * matB[6], matA[3] * matB[1] + matA[4] * matB[4] + matA[5] * matB[7], matA[3] * matB[2] + matA[4] * matB[5] + matA[5] * matB[8],
						matA[6] * matB[0] + matA[7] * matB[3] + matA[8] * matB[6], matA[6] * matB[1] + matA[7] * matB[4] + matA[8] * matB[7], matA[6] * matB[2] + matA[7] * matB[5] + matA[8] * matB[8]
					];
				},
				identity: function (size) {
					switch (size) {
						case 2:
							return [
								1, 0,
								0, 1
							];
							break;
						case 3:
							return [
								1, 0, 0,
								0, 1, 0,
								0, 0, 1
							];
							break;
						case 4:
							return [
								1, 0, 0, 0,
								0, 1, 0, 0,
								0, 0, 1, 0,
								0, 0, 0, 1
							]
							break;
						default: {
							var returnArray = [];
							for (var i = 0; i < size; i++) {
								for (var j = 0; j < size; j++) {
									if (j == i) {
										returnArray.push(1);
									} else {
										returnArray.push(0);
									}
								}
							}
							return returnArray;
							break;
						}
					}
				}
			},
			buildShader(shaderSource, type) {
				var shader = this.gl.createShader(type);
				this.gl.shaderSource(shader, shaderSource);
				this.gl.compileShader(shader);
				console.log(this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS));
				console.log(this.gl.getShaderInfoLog(shader));
				return shader;
			},
			buildProgram(vertexShader, fragmentShader) {
				var program = this.gl.createProgram();
				this.gl.attachShader(program, vertexShader);
				this.gl.attachShader(program, fragmentShader);
				this.gl.linkProgram(program);
				return program;
			},
			start() {
				if (this.mode >= 0) {
					return;
				}
				this.gl = this.canvas.getContext("webgl" || "experimental-webgl", { preserveDrawingBuffer: true, alpha: false });
				if (this.gl == undefined || this.gl == null) {
					this.mode = -2;
					console.log("Error: could not obtain WebGL context");
					alert("Faild to start visualizer!\nMake sure your web browser is up to date!")
					return;
				}
				this.canvas.style.zIndex = "-2";
				this.canvas.style.width = "100%";
				this.canvas.style.height = "100%";
				this.canvas.style.top = "0px";
				this.canvas.style.left = "0px";
				this.canvas.style.position = "absolute";
				document.body.appendChild(this.canvas);

				this.shaders.vertexShaders.fade = this.buildShader(this.shaderSources.fadeVertexShader, this.gl.VERTEX_SHADER);
				this.shaders.fragmentShaders.fade = this.buildShader(this.shaderSources.fadeFragmentShader, this.gl.FRAGMENT_SHADER);
				this.programs.fade = this.buildProgram(this.shaders.vertexShaders.fade, this.shaders.fragmentShaders.fade);
				this.gl.useProgram(this.programs.fade);
				this.attributes.fade.pos = this.gl.getAttribLocation(this.programs.fade, "pos");

				this.uniforms.fade.opacity = this.gl.getUniformLocation(this.programs.fade, "opacity");
				this.uniforms.fade.color = this.gl.getUniformLocation(this.programs.fade, "color");
				this.uniforms.fade.freq = this.gl.getUniformLocation(this.programs.fade, "freq");
				this.gl.uniform1f(this.uniforms.fade.opacity, 1);
				this.gl.enableVertexAttribArray(this.attributes.fade.pos);

				this.buffers.fadeCoverPoints = this.gl.createBuffer();
				this.buffers.fadeCoverTriangles = this.gl.createBuffer();

				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.fadeCoverPoints);
				this.gl.bufferData(this.gl.ARRAY_BUFFER, new Float32Array([-1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0]), this.gl.STATIC_DRAW);

				this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.fadeCoverTriangles);
				this.gl.bufferData(this.gl.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), this.gl.STATIC_DRAW);

				this.shaders.vertexShaders.main = this.buildShader(this.shaderSources.mainVertexShader, this.gl.VERTEX_SHADER);
				this.shaders.fragmentShaders.main = this.buildShader(this.shaderSources.mainFragmentShader, this.gl.FRAGMENT_SHADER);
				this.programs.main = this.buildProgram(this.shaders.vertexShaders.main, this.shaders.fragmentShaders.main);
				this.gl.useProgram(this.programs.main);
				this.attributes.main.pos = this.gl.getAttribLocation(this.programs.main, "pos");
				this.attributes.main.color = this.gl.getAttribLocation(this.programs.main, "color");
				this.attributes.main.normal = this.gl.getAttribLocation(this.programs.main, "normal");
				this.attributes.main.tex = this.gl.getAttribLocation(this.programs.main, "tex");

				this.uniforms.main.world = this.gl.getUniformLocation(this.programs.main, "world");
				this.uniforms.main.perspective = this.gl.getUniformLocation(this.programs.main, "perspective");
				this.uniforms.main.texture = this.gl.getUniformLocation(this.programs.main, "texture");
				this.uniforms.main.ambient_color = this.gl.getUniformLocation(this.programs.main, "ambient_color");
				this.uniforms.main.fog_color = this.gl.getUniformLocation(this.programs.main, "fog_color");
				this.uniforms.main.light_color = this.gl.getUniformLocation(this.programs.main, "light_color");
				this.uniforms.main.light_pos = this.gl.getUniformLocation(this.programs.main, "light_pos");
				this.uniforms.main.normal_matrix = this.gl.getUniformLocation(this.programs.main, "normal_matrix");
				this.uniforms.main.model = this.gl.getUniformLocation(this.programs.main, "model");

				this.gl.enableVertexAttribArray(this.attributes.main.pos);
				this.gl.enableVertexAttribArray(this.attributes.main.color);
				this.gl.enableVertexAttribArray(this.attributes.main.normal);
				this.gl.enableVertexAttribArray(this.attributes.main.tex);


				this.gl.enable(this.gl.BLEND);
				this.gl.blendFunc(this.gl.SRC_ALPHA, this.gl.ONE_MINUS_SRC_ALPHA);
				this.gl.activeTexture(this.gl.TEXTURE0);
				this.textures.transparentBlack = this.gl.createTexture();
				this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.transparentBlack);


				this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([0, 0, 0, 25]));

				this.textures.plainWhite = this.gl.createTexture();
				this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.plainWhite);

				// Fill the texture with a 1x1 white pixel.
				this.gl.texImage2D(this.gl.TEXTURE_2D, 0, this.gl.RGBA, 1, 1, 0, this.gl.RGBA, this.gl.UNSIGNED_BYTE, new Uint8Array([255, 255, 255, 255]));
				//no need to set up the uniform as it defaults to 0 and there is only one texture
				let r = -30 * Math.PI / 180;
				this.gl.bindTexture(this.gl.TEXTURE_2D, this.textures.plainWhite);
				this.gl.uniformMatrix3fv(this.uniforms.main.normal_matrix, false, this.matrix.identity(3));
				this.gl.uniformMatrix4fv(this.uniforms.main.model, false, this.matrix.identity(4));
				this.gl.uniformMatrix4fv(this.uniforms.main.world, false, [
					1, 0, 0, 0,
					0, Math.cos(r), -Math.sin(r), 0,
					0, Math.sin(r),  Math.cos(r), 0,
					0, 0, 0, 1]);
				this.gl.uniformMatrix4fv(this.uniforms.main.perspective, false, this.matrix.identity(4));
				this.gl.uniform3fv(this.uniforms.main.ambient_color, [0.05, 0.05, 0.05]);
				this.gl.uniform3fv(this.uniforms.main.light_color, this.lightColor);
				this.gl.uniform3fv(this.uniforms.main.light_pos, this.lightPos)
				this.resize();
				this.gl.enable(this.gl.DEPTH_TEST);
				this.gl.depthFunc(this.gl.LEQUAL);
				this.gl.clearDepth(1.0);
				this.gl.enable(this.gl.CULL_FACE);
				this.gl.clearColor(0.0, 0.0, 0.0, 1.0);
				this.gl.clear(this.gl.COLOR_BUFFER_BIT | this.gl.DEPTH_BUFFER_BIT);

				// Start generating the cubes, TODO mabye seperate this into a different function?
				var chosenLights = [];
				var possibleList = [];
				var numberOfCubes = 1000;
				this.cubes = [];
				for (var i = 0; i < numberOfCubes; i++) {
					possibleList.push(i);
				}
				for (var i = 0; i < 8; i++) {
					var random = Math.floor(i / 8 * (numberOfCubes - 1));//Math.floor(Math.random()*possibleList.length);
					chosenLights.push(possibleList[random]);
					possibleList.splice(random, 1);
				}
				for (var i = 0; i < numberOfCubes; i++) {
					//Music slection, selects a value in the frquency array for this cube to read
					var ms = Math.floor(i / numberOfCubes * Sound.analyser.frequencyBinCount);
					var x = Math.random() * 150 - 75;
					var y = Math.random() * 150 - 75;
					var z = -Math.random() * 150 - 75;
					var color = [Math.random(), Math.random(), Math.random()];
					var l = -1;
					for (var j = 0; j < 8; j++) {
						if (chosenLights[j] == i) {
							l = j;
							var c = j % 3
							color = [0.0, 0.0, 0.0]
							color[c] = j / 8 * 0.5 + 0.5;

							break;
						}
					}
					this.cubes.push(new Cube(x, y, z, Math.random() * 3 + 3, color, l, ms));

				}

			},
			resize: function () {
				var newWidth = this.canvas.getBoundingClientRect().width;
				var newHeight = this.canvas.getBoundingClientRect().height;
				this.canvas.width = newWidth;
				this.canvas.height = newHeight;
				if (this.gl) {
					this.gl.viewport(0, 0, newWidth, newHeight);
					var f = Math.tan(Math.PI * 0.5 - 0.5 * 90 * Math.PI / 180);
					var rangeInv = 1.0 / (1 - 10000);
					var aspect = newWidth / newHeight;
					perspectiveMatrix = [
						f / aspect, 0, 0, 0,
						0, f, 0, 0,
						0, 0, (1 + 10000) * rangeInv, -1,
						0, 0, 1 * 10000 * rangeInv * 2, 0
					]
					this.gl.uniformMatrix4fv(this.uniforms.main.perspective, false, perspectiveMatrix);
				}
			},
			render: function () {

				var totals = [0, 0, 0];
				for (var i = 0; i < this.lightColor.length; i += 3) {
					totals[0] += this.lightColor[i];
					totals[1] += this.lightColor[i + 1];
					totals[2] += this.lightColor[i + 2];
				}
				var spike = 2;
				lAvg = [Math.pow(totals[0] / 2, spike), Math.pow(totals[1] / 2, spike), Math.pow(totals[2] / 2, spike)]
				this.backgroundColorGoal = lAvg;

				for(var i = 0; i < 3; i++){
					var colorDif = this.backgroundColorGoal[i] - this.backgroundColor[i];
					this.backgroundColor[i] += colorDif * (1 - this.settings.backgroundColorSmoothing);
				}

				this.gl.useProgram(this.programs.fade)
				this.gl.uniform3fv(this.uniforms.fade.color, this.backgroundColor);
				this.gl.uniform1iv(this.uniforms.fade.freq, Sound.data.frequency);

				this.gl.bindBuffer(this.gl.ARRAY_BUFFER, this.buffers.fadeCoverPoints);
				this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, this.buffers.fadeCoverTriangles);

				this.gl.vertexAttribPointer(this.attributes.fade.pos, 2, this.gl.FLOAT, false, 4 * (2), 0);

				this.gl.drawElements(this.gl.TRIANGLES, 6, this.gl.UNSIGNED_SHORT, 0);

				this.gl.useProgram(this.programs.main);

				var camera = this.camera;
				camera.angle += camera.direction;
				if (camera.angle > 90) {
					camera.direction = -0.1;
				}
				if (camera.angle < -90) {
					camera.direction = 0.1;
				}
				camera.height = -Math.sin(camera.angle / 180 * Math.PI) * 500;
				var r = Math.asin(camera.height / Math.sqrt(camera.height ** 2 + camera.target.z ** 2));
				var camMatrix = [
					1, 0, 0, 0,
					0, Math.cos(r), -Math.sin(r), 0,
					0, Math.sin(r),  Math.cos(r), 0,
					0, 0, 0, 1];
				camMatrix = this.matrix.mult4x4([
					1, 0, 0, 0,
					0, 1, 0, 0,
					0, 0, 1, 0,
					0, camera.height, 0, 1]
					, camMatrix);
				this.gl.uniformMatrix4fv(this.uniforms.main.world, false, camMatrix);

				this.gl.clearColor(lAvg[0], lAvg[1], lAvg[2], 1.0);
				this.gl.clear(this.gl.DEPTH_BUFFER_BIT);// TODO Make this change based on settings

				this.gl.uniform3fv(this.uniforms.main.light_color, this.lightColor);
				this.gl.uniform3fv(this.uniforms.main.light_pos, this.lightPos)
				this.gl.uniform3fv(this.uniforms.main.ambient_color, [lAvg[0] / 8, lAvg[1] / 8, lAvg[2] / 8]);
				for (var i = 0; i < this.cubes.length; i++) {
					var cc = this.cubes[i];
					cc.update();
					this.gl.bindBuffer(this.gl.ARRAY_BUFFER, cc.VBO);
					this.gl.bindBuffer(this.gl.ELEMENT_ARRAY_BUFFER, cc.IBO);
					//[x, y, z, r, g, b, nx, ny, nz, tx, ty]
					this.gl.uniformMatrix4fv(this.uniforms.main.model, false, cc.modelMat);
					this.gl.uniformMatrix3fv(this.uniforms.main.normal_matrix, false, cc.normalMat);

					this.gl.vertexAttribPointer(this.attributes.main.pos, 3, this.gl.FLOAT, false, 4 * (11), 0);
					this.gl.vertexAttribPointer(this.attributes.main.color, 3, this.gl.FLOAT, false, 4 * (11), 3 * 4);
					this.gl.vertexAttribPointer(this.attributes.main.normal, 3, this.gl.FLOAT, false, 4 * (11), 6 * 4);
					this.gl.vertexAttribPointer(this.attributes.main.tex, 2, this.gl.FLOAT, false, 4 * (11), 9 * 4);

					this.gl.drawElements(this.gl.TRIANGLES, cc.bufferLength, this.gl.UNSIGNED_SHORT, 0);

					//cc.buildModelMat();
				}
			}


		}
		function Song(fileElement, fileNumber, idNumber = Player.songs.length) {
			this.length = 0;
			this.id = idNumber;
			this.title = "Unknown";
			this.fileName = fileElement.files[fileNumber].name;
			this.artist = "Unkown Artist";
			this.album = "Unkown Album";
			this.composer = "";
			this.cover = new Image(100, 100);//cover image file if one exists
			this.songTitleTag = document.createElement("div");
			this.flagged = false;//if true this song has an error that wont allow it to play
			this.format = "";
			this.hasProgressed = false;//helps catch songs that will not load
			this.fileElement = fileElement;//describes which file element holds this song's files
			this.fileNumber = fileNumber;
			this.URL = URL.createObjectURL(fileElement.files[fileNumber]);//used to store the URL created to pass song as a source to the audio player
			this.active = true;//so user can deactivate a song

			this.playlistItem = document.createElement("div");
			this.songTitleTag.innerHTML = this.fileName;

			this.playlistItem.classList.add("playlistItem");
			this.songTitleTag.classList.add("songTitle");
			this.cover.classList.add("songCover");

			this.isDisabled = function () {
				if (!this.active || this.flagged) {
					return true;
				}
				return false;
			}
			this.play = function () {//returns true if successful
				start();//incase the code has not started yet

				if (Sound.mic.playing) {
					Sound.mic.playing = false;
					Sound.mic.source.disconnect(Sound.analyser);
					Sound.state.source = 0;
				}

				if (this.isDisabled()) {
					return false;
				}

				if (Player.songId >= 0) {
					Player.songs[Player.songId].playlistItem.classList.remove("songPlaying");
				}

				Player.songId = this.id;
				Sound.gainNode.gain.setValueAtTime(Player.volume, Sound.ctx.currentTime);
				audioSrc.src = this.URL;
				audioEle.load();
				audioEle.play().then(function () {
					Player.songOrder[Player.songNumber].playlistItem.classList.add("songPlaying");
				}).catch(function (e) {
					console.log(e);
				});
				setTimeout(function () {
					var song = Player.songs[Player.songId];
					if (!song.hasProgressed) {
						song.flagged = true;
						song.active = false;
						song.checkBox.checked = false;
						song.checkBox.title = "This song failed to load.";
						song.checkBox.style.cursor = "not-allowed";
						song.playlistItem.classList.add("songInError");
						song.cover.src = Player.resources.errorCover.src;
						Player.nextSong();
					}
				}, 1000)

				for (var i = 0; i < Player.songOrder.length; i++) {//find itself in the songOrder list to get the number so play can coninue from there if shuffeled
					if (Player.songOrder[i] === this) {
						Player.songNumber = i;
						break;
					}
				}
				return true;
			}
			//this.playlistItem.style.cursor = "grab";
			this.playlistItem.addEventListener("click", function () {
				var songId = parseInt(this.id.substring(5, 10), 10);
				Player.songs[songId].play();
			});

			this.playlistItem.draggable = true;
			this.playlistItem.addEventListener("dragstart", function (e) {
				e.dataTransfer.setData("text", e.target.id);
			});
			this.playlistItem.addEventListener("dragover", function (e) {
				e.preventDefault();
			});
			this.playlistItem.addEventListener("drop", function (e) {
				e.preventDefault();
				var id = e.dataTransfer.getData("text");
				var movedEle = document.getElementById(id);
				if (movingSongId === -1) {
					placeHolder.style.height = "160px";
					playlistEle.insertBefore(placeHolder, movedEle);
					movedEle.style.height = "0px";
					setTimeout(function () {
						Player.songs[movingSongId].playlistItem.removeAttribute("style");
						placeHolder.style.height = "0px";
						movingSongId = -1;
					}, 1)
				}
				playlistEle.insertBefore(movedEle, this);

				var songId = parseInt(this.id.substring(5, 10), 10);
				var movedId = parseInt(movedEle.id.substring(5, 10), 10);
				if (movingSongId === -1)
					movingSongId = movedId;
				var oldIndex = -1;
				var newIndex = 0;

				for (; newIndex < Player.songOrder.length; newIndex++) {
					if (Player.songOrder[newIndex].id == songId) {
						Player.songOrder.splice(newIndex, 0, Player.songs[movedId]);//insert the song before the one that is reciving the drop
						newIndex++;
					}
					if (Player.songOrder[newIndex].id == movedId) {
						oldIndex = newIndex;
					}
				}
				if (oldIndex >= 0) {
					Player.songOrder.splice(oldIndex, 1);//remove old song if it was found
				}

				if (Player.songId >= 0) {
					for (var i = 0; i < Player.songOrder.length; i++) {//Update the song number as the list changed
						if (Player.songOrder[i].id === Player.songId) {
							Player.songNumber = i;
							break;
						}
					}
				}
			});

			var idString = (Player.songs.length).toString();

			while (idString.length < 5) {
				idString = "0" + idString;
			}

			this.playlistItem.id = "song" + idString;
			this.checkBox = document.createElement("input");
			this.checkBox.type = "checkbox";
			this.checkBox.style.cursor = "pointer";
			this.checkBox.checked = true;
			this.checkBox.title = "Disable Song";
			this.cover.src = Player.resources.defaultCover.src;
			this.checkBox.addEventListener("click", function () {
				var songId = parseInt(this.parentElement.id.substring(5, 10), 10);
				Player.songs[songId].active = this.checked;
				if (this.checked && !Player.songs[songId].isDisabled()) {//checks if the song is Disabled for another reason before activating song.
					Player.songs[songId].playlistItem.classList.remove("songDisabled");
				} else if (this.checked) {//if the last check failed but the check mark was checked, keep the song Disabled as it may be flagged.
					this.checked = false;
					Player.songs[songId].active = false;
					this.style.cursor = "not-allowed";
					this.title = "An error occurred with this song file";
					Player.songs[songId].playlistItem.classList.remove("songDisabled");
					Player.songs[songId].playlistItem.classList.add("songInError");
					Player.songs[songId].cover.src = Player.resources.errorCover.src;
				} else {
					Player.songs[songId].playlistItem.classList.add("songDisabled");
					this.title = "Enable Song";
				}
				event.stopPropagation();
			});

			this.playlistItem.appendChild(this.cover);
			this.playlistItem.appendChild(this.songTitleTag);
			this.playlistItem.appendChild(this.checkBox);
			playlistEle.insertBefore(this.playlistItem, addSongEle);
		}
		var Sound = {
			ctx: null,
			gainNode: null,
			analyser: null,
			state: {
				volume: 0,
				source: -1,//-1 for none, 0 for music, 1 for microphone
			},
			mic: {
				source: null,//the aduio context source
				playing: false//tells if the microphone is active or not
			},
			music: {
				source: null//the html element that will play the music is linked here
				//playing is not needed as this will not be controlled by the Sound object but the player object
			},
			data: {
				frequency: new Uint8Array(1),
				waveform: new Uint8Array(1)
			}

		}

		var Player = {
			songs: [],
			songOrder: [],
			songId: -1,//Identifies the song in the songs list currently playing, this list can only be added to, cannot change order or the ID system breaks down
			songNumber: -1,//Identifies the song in the songOrder list, which is a list of song ID's that correspond to the songs list.
			paused: true,
			playing: false,
			shuffle: false,
			volume: 1,
			repeat: 0,//0 for no repeats, 1 for repeat playlist, 2 for repeat song, 3 for play one song
			showPanel: true,
			controls: {//List of HTML elements for the controls on screen
				controlContainer: null,
				playButton: null,//play and pause
				timeLine: null,
				timeBack: null,//background of the line
				timeDot: null,
				fastforwardButton: null,
				rewindButton: null,
				backButton: null,
				skipButton: null,
				volumeDot: null,
				volumeLine: null,
				volumeBack: null,
				repeatButton: null,
				shuffleButton: null,
				optionButton: null
			},
			resources: {//List of images
				pause: new Image(256, 256),
				play: new Image(256, 256),
				repeatAll: new Image(256, 256),
				repeatOne: new Image(256, 256),
				repeatNone: new Image(256, 256),
				shuffleOn: new Image(256, 256),
				shuffleOff: new Image(256, 256),
				fastforward: new Image(256, 256),
				skip: new Image(256, 256),
				back: new Image(256, 256),
				rewind: new Image(256, 256),
				dot: new Image(256, 256),
				pauseDisabled: new Image(256, 256),
				playDisabled: new Image(256, 256),
				skipDisabled: new Image(256, 256),
				backDisabled: new Image(256, 256),
				rewindDisabled: new Image(256, 256),
				fastforwardDisabled: new Image(256, 256),
				defaultCover: new Image(256, 256),
				errorCover: new Image(256, 256),

			},
			loadResources: function () {
				this.resources.defaultCover.src = "Audio_Resources/Disc.png";
				this.resources.errorCover.src = "Audio_Resources/DiscBroken.png";
			},
			loadSongs: function (fileList) {
				var fLength = fileList.length
				for (var sc = 0; sc < fLength; sc++) {
					var newSong = new Song(fileEle, sc);
					Player.songs.push(newSong);
					Player.songOrder.push(Player.songs[Player.songs.length - 1]);//add to the song order
				}
			},
			nextSong: function () {
				switch (this.repeat) {
					case 0:
						this.songNumber++;
						if (this.songNumber >= this.songOrder.length) {//we have reached the end of the playlist
							this.songNumber = 0;
							return;
						}
						var suc = this.songOrder[this.songNumber].play();
						if (!suc) {//the play failed
							Player.nextSong();
						}

						break;
					case 1:
						this.songNumber++;
						if (this.songNumber >= this.songOrder.length) {
							this.songNumber = 0;
						}
						var suc = this.songOrder[this.songNumber].play();
						if (!suc) {//the play failed
							Player.nextSong();
						}

						break;
					case 2:
						if (this.songOrder[this.songNumber].isDisabled())
							return;
						this.songOrder[this.songNumber].play();

						break;
					case 3:
						return;
						break;
					default:
						return;


				}
			},
			shuffleSongs: function () {
				var remainingSongs = Player.songOrder.slice(0);
				for (var i = 0; remainingSongs.length > 0; i++) {
					var numberOfSongs = remainingSongs.length;
					var songSelected = Math.floor(Math.random() * numberOfSongs);
					Player.songOrder[i] = remainingSongs[songSelected];
					playlistEle.insertBefore(Player.songOrder[i].playlistItem, addSongEle);
					remainingSongs.splice(songSelected, 1);
				}
			}

		}

		var fileElements = [];//a list of file elements that can hold the music files

		function start() {
			if (hasStarted)
				return;
			hasStarted = true;
			Sound.ctx = new (window.AudioContext || window.webkitAudioContext)();
			Sound.music.source = Sound.ctx.createMediaElementSource(audioEle);
			Sound.analyser = Sound.ctx.createAnalyser();
			Sound.gainNode = Sound.ctx.createGain();
			Sound.music.source.connect(Sound.analyser);
			Sound.analyser.connect(Sound.gainNode);
			Sound.gainNode.connect(Sound.ctx.destination);
			//Sound.analyser.smoothingTimeConstant = 0;
			Sound.gainNode.gain.setValueAtTime(0, Sound.ctx.currentTime);//Mute audio so it doesn't create feedback
			Sound.analyser.fftSize = 128;
			fileEle.addEventListener("change", function () {
				Sound.gainNode.gain.setValueAtTime(1, Sound.ctx.currentTime);
				if (Sound.mic.playing) {
					Sound.mic.source.disconnect(Sound.analyser);
					Sound.mic.playing = false;
				}
				Player.loadSongs(fileEle.files);
			})
			//fEle.addEventListener("change",function(){audioSrc.src=URL.createObjectURL(fEle.files[0]);aEle.load();aEle.play();gainNode.gain.setValueAtTime(1,Sound.ctx.currentTime);if(mSource){mSource.disconnect(analyser)}})
			Sound.data.frequency = new Uint8Array(Sound.analyser.frequencyBinCount);
			Sound.data.waveform = new Uint8Array(Sound.analyser.frequencyBinCount);
			Player.loadResources();
			Graphics.start();
			update();
		};
		async function requestMic() {
			if (navigator.mediaDevices.getUserMedia) {
				var allDevices = await navigator.mediaDevices.enumerateDevices();
				let length = allDevices.length;
				audioDevices = [];
				while (inputSelectEle.firstChild) {
					inputSelectEle.removeChild(inputSelectEle.firstChild);
				}
				for (let i = 0; i < length; i++) {
					if (allDevices[i].kind == "audioinput") {
						audioDevices.push(allDevices[i]);
						var newChild = document.createElement("option");
						newChild.innerHTML = allDevices[i].label;
						newChild.value = audioDevices.length - 1;
						inputSelectEle.appendChild(newChild);
					}
				}
				if (audioDevices.length > 0) {
					tryMic(0);
				}

			} else {
				alert("***Could not obtain Microphone access***\nClick 'Load a File' to upload an audio file instead")
			}

		}
		function tryMic(index) {
			if (index >= 0 && audioDevices.length) {
				if (Sound.mic.playing) {
					Sound.mic.source.disconnect(Sound.analyser);//disconnect if connected
					Sound.mic.source = null;
					Sound.mic.playing = false;
				}
				navigator.mediaDevices.getUserMedia({ audio: { deviceId: audioDevices[index].deviceId } }).then(function (stream) {
					Sound.mic.source = Sound.ctx.createMediaStreamSource(stream);
					Sound.mic.source.connect(Sound.analyser);
					Sound.mic.playing = true;
					Sound.state.source = 1;
					Sound.gainNode.gain.setValueAtTime(0, Sound.ctx.currentTime);
					audioEle.pause();
					console.log(stream);

				}).catch(errorCallback);
			}
		}
		function update() {
			requestAnimationFrame(update);
			Sound.analyser.getByteFrequencyData(Sound.data.frequency);
			Sound.analyser.getByteTimeDomainData(Sound.data.waveform);

			var width = window.innerWidth;
			var height = window.innerHeight;
			canvas.width = width;
			canvas.height = height;
			ct.clearRect(0, 0, width, height);
			ct.strokeStyle = "White";
			ct.fillStyle = "rgba(0, 255, 0, 0.5)";
			ct.beginPath();
			ct.moveTo(0, -Sound.data.frequency[0] + (height / 2));
			for (var i = 1; i < Sound.data.frequency.length; i++) {
				ct.lineTo(width / Sound.data.frequency.length * i, -(Sound.data.frequency[i] / 255 * height) + height);
			}
			ct.lineTo(width, height);
			ct.lineTo(0, height);
			//ct.fill();
			//ct.stroke();

			ct.beginPath();
			ct.moveTo(0, -Sound.data.waveform[0] + height / 2);
			for (var i = 1; i < Sound.data.waveform.length; i++) {
				ct.lineTo(width / Sound.data.waveform.length * i, -(Sound.data.waveform[i] / 255 * height) + height);
			}
			ct.lineTo(width, height);
			ct.lineTo(0, height);
			ct.strokeStyle = "rgba(255, 255, 0, 0.5)";

			//ct.stroke();
			Graphics.render();
		}
		var errorCallback = function (e) {
			alert("***Could not obtain Microphone access***\nClick 'Load a File' to upload an audio file instead\n" + e);
			console.log(e);
		};
	</script>

</body>

</html>